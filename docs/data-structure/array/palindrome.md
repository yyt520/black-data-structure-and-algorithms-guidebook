---
nav:
  title: 数据结构
  order: 1
group:
  title: 数组
  order: 3
title: 字符串 - 回文字符串
order: 3
---

# 字符串 - 回文字符串

- 计算回文子字符串的个数

## 回文子字符串统计

### 中心拓展法

计算有多少个回文子串的最朴素方法就是枚举出所有的回文子串，而枚举出所有的回文字串又有两种思路，分别是：

- 枚举出所有的子串，然后再判断这些子串是否是回文；
- 枚举每一个可能的回文中心，然后用两个指针分别向左右两边拓展，当两个指针指向的元素相同的时候就拓展，否则停止拓展。

假设字符串的长度为 $n$。我们可以看出前者会用 $O(n^2)$ 的时间枚举出所有的子串 $s[l_i \cdots r_i]$，然后再用 $O(r_i - l_i + 1)$ 的时间检测当前的子串是否是回文，整个算法的时间复杂度是 $O(n^3)$。而后者枚举回文中心的是 $O(n)$ 的，对于每个回文中心拓展的次数也是 $O(n)$ 的，所以时间复杂度是 $O(n^2)$。所以我们选择第二种方法来枚举所有的回文子串。

在实现的时候，我们需要处理一个问题，即如何有序地枚举所有可能的回文中心，我们需要考虑回文长度是奇数和回文长度是偶数的两种情况。

- 如果回文长度是奇数，那么回文中心是一个字符；
- 如果回文长度是偶数，那么中心是两个字符。

当然你可以做两次循环来分别枚举奇数长度和偶数长度的回文，但是我们也可以用一个循环搞定。我们不妨写一组出来观察观察，假设 $n = 4$，我们可以把可能的回文中心列出来：

<br />

| 编号 $i$ | 回文中心左起始位置 $l_i$ | 回文中心右起始位置 $r_i$ |
| :------- | :----------------------- | :----------------------- |
| 0        | 0                        | 0                        |
| 1        | 0                        | 1                        |
| 2        | 1                        | 1                        |
| 3        | 1                        | 2                        |
| 4        | 2                        | 2                        |
| 5        | 2                        | 3                        |
| 6        | 3                        | 3                        |

由此我们可以看出长度为 $n$ 的字符串会生成 $2n-1$ 组回文中心 $[l_i, r_i]$，其中 $l_i = \lfloor \frac{i}{2} \rfloor$，$r_i = l_i + (i \bmod 2)$。这样我们只要从 0 到 $2n-2$ 遍历 $i$，就可以得到所有可能的回文中心，这样就把奇数长度和偶数长度两种情况统一起来了。

```js
var countSubstrings = function (s) {
  const len = s.length;
  let ans = 0;
  for (let i = 0; i < 2 * len - 1; i++) {
    let left = i / 2,
      right = i / 2 + (i % 2);
    while (left >= 0 && right < len && s.charAt(left) === s.charAt(right)) {
      --left;
      ++right;
      ++ans;
    }
  }
  return ans;
};
```

### Manacher 算法
